<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wrapper for `TokenStream::into_iter` allowing not only to iterate on tokens but also to parse simple structures like types or expressions, though it does not make any claims about their correctness."><title>TokenParser in proc_macro_utils - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="proc_macro_utils" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../proc_macro_utils/index.html">proc_<wbr>macro_<wbr>utils</a><span class="version">0.10.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Token<wbr>Parser</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#construction" title="Construction">Construction</a></li><li><a href="#peeking" title="Peeking">Peeking</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.into_token_stream" title="into_token_stream">into_token_stream</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.new_generic" title="new_generic">new_generic</a></li><li><a href="#method.next_bool" title="next_bool">next_bool</a></li><li><a href="#method.next_braced" title="next_braced">next_braced</a></li><li><a href="#method.next_bracketed" title="next_bracketed">next_bracketed</a></li><li><a href="#method.next_expression" title="next_expression">next_expression</a></li><li><a href="#method.next_group" title="next_group">next_group</a></li><li><a href="#method.next_ident" title="next_ident">next_ident</a></li><li><a href="#method.next_if" title="next_if">next_if</a></li><li><a href="#method.next_if_each" title="next_if_each">next_if_each</a></li><li><a href="#method.next_if_each_alone" title="next_if_each_alone">next_if_each_alone</a></li><li><a href="#method.next_keyword" title="next_keyword">next_keyword</a></li><li><a href="#method.next_literal" title="next_literal">next_literal</a></li><li><a href="#method.next_macro_rules_tt" title="next_macro_rules_tt">next_macro_rules_tt</a></li><li><a href="#method.next_n" title="next_n">next_n</a></li><li><a href="#method.next_n_alone" title="next_n_alone">next_n_alone</a></li><li><a href="#method.next_parenthesized" title="next_parenthesized">next_parenthesized</a></li><li><a href="#method.next_punct" title="next_punct">next_punct</a></li><li><a href="#method.next_punctuation_group" title="next_punctuation_group">next_punctuation_group</a></li><li><a href="#method.next_string" title="next_string">next_string</a></li><li><a href="#method.next_tt" title="next_tt">next_tt</a></li><li><a href="#method.next_tt_and" title="next_tt_and">next_tt_and</a></li><li><a href="#method.next_tt_and_and" title="next_tt_and_and">next_tt_and_and</a></li><li><a href="#method.next_tt_and_eq" title="next_tt_and_eq">next_tt_and_eq</a></li><li><a href="#method.next_tt_at" title="next_tt_at">next_tt_at</a></li><li><a href="#method.next_tt_caret" title="next_tt_caret">next_tt_caret</a></li><li><a href="#method.next_tt_caret_eq" title="next_tt_caret_eq">next_tt_caret_eq</a></li><li><a href="#method.next_tt_colon" title="next_tt_colon">next_tt_colon</a></li><li><a href="#method.next_tt_comma" title="next_tt_comma">next_tt_comma</a></li><li><a href="#method.next_tt_dollar" title="next_tt_dollar">next_tt_dollar</a></li><li><a href="#method.next_tt_dot" title="next_tt_dot">next_tt_dot</a></li><li><a href="#method.next_tt_dot_dot" title="next_tt_dot_dot">next_tt_dot_dot</a></li><li><a href="#method.next_tt_dot_dot_dot" title="next_tt_dot_dot_dot">next_tt_dot_dot_dot</a></li><li><a href="#method.next_tt_dot_dot_eq" title="next_tt_dot_dot_eq">next_tt_dot_dot_eq</a></li><li><a href="#method.next_tt_eq" title="next_tt_eq">next_tt_eq</a></li><li><a href="#method.next_tt_eq_eq" title="next_tt_eq_eq">next_tt_eq_eq</a></li><li><a href="#method.next_tt_fat_arrow" title="next_tt_fat_arrow">next_tt_fat_arrow</a></li><li><a href="#method.next_tt_ge" title="next_tt_ge">next_tt_ge</a></li><li><a href="#method.next_tt_gt" title="next_tt_gt">next_tt_gt</a></li><li><a href="#method.next_tt_le" title="next_tt_le">next_tt_le</a></li><li><a href="#method.next_tt_lt" title="next_tt_lt">next_tt_lt</a></li><li><a href="#method.next_tt_minus" title="next_tt_minus">next_tt_minus</a></li><li><a href="#method.next_tt_minus_eq" title="next_tt_minus_eq">next_tt_minus_eq</a></li><li><a href="#method.next_tt_ne" title="next_tt_ne">next_tt_ne</a></li><li><a href="#method.next_tt_not" title="next_tt_not">next_tt_not</a></li><li><a href="#method.next_tt_or" title="next_tt_or">next_tt_or</a></li><li><a href="#method.next_tt_or_eq" title="next_tt_or_eq">next_tt_or_eq</a></li><li><a href="#method.next_tt_or_or" title="next_tt_or_or">next_tt_or_or</a></li><li><a href="#method.next_tt_path_sep" title="next_tt_path_sep">next_tt_path_sep</a></li><li><a href="#method.next_tt_percent" title="next_tt_percent">next_tt_percent</a></li><li><a href="#method.next_tt_percent_eq" title="next_tt_percent_eq">next_tt_percent_eq</a></li><li><a href="#method.next_tt_plus" title="next_tt_plus">next_tt_plus</a></li><li><a href="#method.next_tt_plus_eq" title="next_tt_plus_eq">next_tt_plus_eq</a></li><li><a href="#method.next_tt_pound" title="next_tt_pound">next_tt_pound</a></li><li><a href="#method.next_tt_question" title="next_tt_question">next_tt_question</a></li><li><a href="#method.next_tt_r_arrow" title="next_tt_r_arrow">next_tt_r_arrow</a></li><li><a href="#method.next_tt_semi" title="next_tt_semi">next_tt_semi</a></li><li><a href="#method.next_tt_shl" title="next_tt_shl">next_tt_shl</a></li><li><a href="#method.next_tt_shl_eq" title="next_tt_shl_eq">next_tt_shl_eq</a></li><li><a href="#method.next_tt_shr" title="next_tt_shr">next_tt_shr</a></li><li><a href="#method.next_tt_shr_eq" title="next_tt_shr_eq">next_tt_shr_eq</a></li><li><a href="#method.next_tt_slash" title="next_tt_slash">next_tt_slash</a></li><li><a href="#method.next_tt_slash_eq" title="next_tt_slash_eq">next_tt_slash_eq</a></li><li><a href="#method.next_tt_star" title="next_tt_star">next_tt_star</a></li><li><a href="#method.next_tt_star_eq" title="next_tt_star_eq">next_tt_star_eq</a></li><li><a href="#method.next_tt_tilde" title="next_tt_tilde">next_tt_tilde</a></li><li><a href="#method.next_type" title="next_type">next_type</a></li><li><a href="#method.next_until" title="next_until">next_until</a></li><li><a href="#method.next_until_alone" title="next_until_alone">next_until_alone</a></li><li><a href="#method.next_while" title="next_while">next_while</a></li><li><a href="#method.next_while_alone" title="next_while_alone">next_while_alone</a></li><li><a href="#method.peek" title="peek">peek</a></li><li><a href="#method.peek_braced" title="peek_braced">peek_braced</a></li><li><a href="#method.peek_bracketed" title="peek_bracketed">peek_bracketed</a></li><li><a href="#method.peek_group" title="peek_group">peek_group</a></li><li><a href="#method.peek_ident" title="peek_ident">peek_ident</a></li><li><a href="#method.peek_if_each" title="peek_if_each">peek_if_each</a></li><li><a href="#method.peek_keyword" title="peek_keyword">peek_keyword</a></li><li><a href="#method.peek_literal" title="peek_literal">peek_literal</a></li><li><a href="#method.peek_n" title="peek_n">peek_n</a></li><li><a href="#method.peek_n_braced" title="peek_n_braced">peek_n_braced</a></li><li><a href="#method.peek_n_bracketed" title="peek_n_bracketed">peek_n_bracketed</a></li><li><a href="#method.peek_n_group" title="peek_n_group">peek_n_group</a></li><li><a href="#method.peek_n_ident" title="peek_n_ident">peek_n_ident</a></li><li><a href="#method.peek_n_if_each" title="peek_n_if_each">peek_n_if_each</a></li><li><a href="#method.peek_n_if_each_alone" title="peek_n_if_each_alone">peek_n_if_each_alone</a></li><li><a href="#method.peek_n_keyword" title="peek_n_keyword">peek_n_keyword</a></li><li><a href="#method.peek_n_literal" title="peek_n_literal">peek_n_literal</a></li><li><a href="#method.peek_n_parenthesized" title="peek_n_parenthesized">peek_n_parenthesized</a></li><li><a href="#method.peek_n_punct" title="peek_n_punct">peek_n_punct</a></li><li><a href="#method.peek_n_tt" title="peek_n_tt">peek_n_tt</a></li><li><a href="#method.peek_n_tt_and" title="peek_n_tt_and">peek_n_tt_and</a></li><li><a href="#method.peek_n_tt_and_and" title="peek_n_tt_and_and">peek_n_tt_and_and</a></li><li><a href="#method.peek_n_tt_and_eq" title="peek_n_tt_and_eq">peek_n_tt_and_eq</a></li><li><a href="#method.peek_n_tt_at" title="peek_n_tt_at">peek_n_tt_at</a></li><li><a href="#method.peek_n_tt_caret" title="peek_n_tt_caret">peek_n_tt_caret</a></li><li><a href="#method.peek_n_tt_caret_eq" title="peek_n_tt_caret_eq">peek_n_tt_caret_eq</a></li><li><a href="#method.peek_n_tt_colon" title="peek_n_tt_colon">peek_n_tt_colon</a></li><li><a href="#method.peek_n_tt_comma" title="peek_n_tt_comma">peek_n_tt_comma</a></li><li><a href="#method.peek_n_tt_dollar" title="peek_n_tt_dollar">peek_n_tt_dollar</a></li><li><a href="#method.peek_n_tt_dot" title="peek_n_tt_dot">peek_n_tt_dot</a></li><li><a href="#method.peek_n_tt_dot_dot" title="peek_n_tt_dot_dot">peek_n_tt_dot_dot</a></li><li><a href="#method.peek_n_tt_dot_dot_dot" title="peek_n_tt_dot_dot_dot">peek_n_tt_dot_dot_dot</a></li><li><a href="#method.peek_n_tt_dot_dot_eq" title="peek_n_tt_dot_dot_eq">peek_n_tt_dot_dot_eq</a></li><li><a href="#method.peek_n_tt_eq" title="peek_n_tt_eq">peek_n_tt_eq</a></li><li><a href="#method.peek_n_tt_eq_eq" title="peek_n_tt_eq_eq">peek_n_tt_eq_eq</a></li><li><a href="#method.peek_n_tt_fat_arrow" title="peek_n_tt_fat_arrow">peek_n_tt_fat_arrow</a></li><li><a href="#method.peek_n_tt_ge" title="peek_n_tt_ge">peek_n_tt_ge</a></li><li><a href="#method.peek_n_tt_gt" title="peek_n_tt_gt">peek_n_tt_gt</a></li><li><a href="#method.peek_n_tt_le" title="peek_n_tt_le">peek_n_tt_le</a></li><li><a href="#method.peek_n_tt_lt" title="peek_n_tt_lt">peek_n_tt_lt</a></li><li><a href="#method.peek_n_tt_minus" title="peek_n_tt_minus">peek_n_tt_minus</a></li><li><a href="#method.peek_n_tt_minus_eq" title="peek_n_tt_minus_eq">peek_n_tt_minus_eq</a></li><li><a href="#method.peek_n_tt_ne" title="peek_n_tt_ne">peek_n_tt_ne</a></li><li><a href="#method.peek_n_tt_not" title="peek_n_tt_not">peek_n_tt_not</a></li><li><a href="#method.peek_n_tt_or" title="peek_n_tt_or">peek_n_tt_or</a></li><li><a href="#method.peek_n_tt_or_eq" title="peek_n_tt_or_eq">peek_n_tt_or_eq</a></li><li><a href="#method.peek_n_tt_or_or" title="peek_n_tt_or_or">peek_n_tt_or_or</a></li><li><a href="#method.peek_n_tt_path_sep" title="peek_n_tt_path_sep">peek_n_tt_path_sep</a></li><li><a href="#method.peek_n_tt_percent" title="peek_n_tt_percent">peek_n_tt_percent</a></li><li><a href="#method.peek_n_tt_percent_eq" title="peek_n_tt_percent_eq">peek_n_tt_percent_eq</a></li><li><a href="#method.peek_n_tt_plus" title="peek_n_tt_plus">peek_n_tt_plus</a></li><li><a href="#method.peek_n_tt_plus_eq" title="peek_n_tt_plus_eq">peek_n_tt_plus_eq</a></li><li><a href="#method.peek_n_tt_pound" title="peek_n_tt_pound">peek_n_tt_pound</a></li><li><a href="#method.peek_n_tt_question" title="peek_n_tt_question">peek_n_tt_question</a></li><li><a href="#method.peek_n_tt_r_arrow" title="peek_n_tt_r_arrow">peek_n_tt_r_arrow</a></li><li><a href="#method.peek_n_tt_semi" title="peek_n_tt_semi">peek_n_tt_semi</a></li><li><a href="#method.peek_n_tt_shl" title="peek_n_tt_shl">peek_n_tt_shl</a></li><li><a href="#method.peek_n_tt_shl_eq" title="peek_n_tt_shl_eq">peek_n_tt_shl_eq</a></li><li><a href="#method.peek_n_tt_shr" title="peek_n_tt_shr">peek_n_tt_shr</a></li><li><a href="#method.peek_n_tt_shr_eq" title="peek_n_tt_shr_eq">peek_n_tt_shr_eq</a></li><li><a href="#method.peek_n_tt_slash" title="peek_n_tt_slash">peek_n_tt_slash</a></li><li><a href="#method.peek_n_tt_slash_eq" title="peek_n_tt_slash_eq">peek_n_tt_slash_eq</a></li><li><a href="#method.peek_n_tt_star" title="peek_n_tt_star">peek_n_tt_star</a></li><li><a href="#method.peek_n_tt_star_eq" title="peek_n_tt_star_eq">peek_n_tt_star_eq</a></li><li><a href="#method.peek_n_tt_tilde" title="peek_n_tt_tilde">peek_n_tt_tilde</a></li><li><a href="#method.peek_parenthesized" title="peek_parenthesized">peek_parenthesized</a></li><li><a href="#method.peek_punct" title="peek_punct">peek_punct</a></li><li><a href="#method.peek_range" title="peek_range">peek_range</a></li><li><a href="#method.peek_range_alone" title="peek_range_alone">peek_range_alone</a></li><li><a href="#method.peek_tt" title="peek_tt">peek_tt</a></li><li><a href="#method.peek_tt_and" title="peek_tt_and">peek_tt_and</a></li><li><a href="#method.peek_tt_and_and" title="peek_tt_and_and">peek_tt_and_and</a></li><li><a href="#method.peek_tt_and_eq" title="peek_tt_and_eq">peek_tt_and_eq</a></li><li><a href="#method.peek_tt_at" title="peek_tt_at">peek_tt_at</a></li><li><a href="#method.peek_tt_caret" title="peek_tt_caret">peek_tt_caret</a></li><li><a href="#method.peek_tt_caret_eq" title="peek_tt_caret_eq">peek_tt_caret_eq</a></li><li><a href="#method.peek_tt_colon" title="peek_tt_colon">peek_tt_colon</a></li><li><a href="#method.peek_tt_comma" title="peek_tt_comma">peek_tt_comma</a></li><li><a href="#method.peek_tt_dollar" title="peek_tt_dollar">peek_tt_dollar</a></li><li><a href="#method.peek_tt_dot" title="peek_tt_dot">peek_tt_dot</a></li><li><a href="#method.peek_tt_dot_dot" title="peek_tt_dot_dot">peek_tt_dot_dot</a></li><li><a href="#method.peek_tt_dot_dot_dot" title="peek_tt_dot_dot_dot">peek_tt_dot_dot_dot</a></li><li><a href="#method.peek_tt_dot_dot_eq" title="peek_tt_dot_dot_eq">peek_tt_dot_dot_eq</a></li><li><a href="#method.peek_tt_eq" title="peek_tt_eq">peek_tt_eq</a></li><li><a href="#method.peek_tt_eq_eq" title="peek_tt_eq_eq">peek_tt_eq_eq</a></li><li><a href="#method.peek_tt_fat_arrow" title="peek_tt_fat_arrow">peek_tt_fat_arrow</a></li><li><a href="#method.peek_tt_ge" title="peek_tt_ge">peek_tt_ge</a></li><li><a href="#method.peek_tt_gt" title="peek_tt_gt">peek_tt_gt</a></li><li><a href="#method.peek_tt_le" title="peek_tt_le">peek_tt_le</a></li><li><a href="#method.peek_tt_lt" title="peek_tt_lt">peek_tt_lt</a></li><li><a href="#method.peek_tt_minus" title="peek_tt_minus">peek_tt_minus</a></li><li><a href="#method.peek_tt_minus_eq" title="peek_tt_minus_eq">peek_tt_minus_eq</a></li><li><a href="#method.peek_tt_ne" title="peek_tt_ne">peek_tt_ne</a></li><li><a href="#method.peek_tt_not" title="peek_tt_not">peek_tt_not</a></li><li><a href="#method.peek_tt_or" title="peek_tt_or">peek_tt_or</a></li><li><a href="#method.peek_tt_or_eq" title="peek_tt_or_eq">peek_tt_or_eq</a></li><li><a href="#method.peek_tt_or_or" title="peek_tt_or_or">peek_tt_or_or</a></li><li><a href="#method.peek_tt_path_sep" title="peek_tt_path_sep">peek_tt_path_sep</a></li><li><a href="#method.peek_tt_percent" title="peek_tt_percent">peek_tt_percent</a></li><li><a href="#method.peek_tt_percent_eq" title="peek_tt_percent_eq">peek_tt_percent_eq</a></li><li><a href="#method.peek_tt_plus" title="peek_tt_plus">peek_tt_plus</a></li><li><a href="#method.peek_tt_plus_eq" title="peek_tt_plus_eq">peek_tt_plus_eq</a></li><li><a href="#method.peek_tt_pound" title="peek_tt_pound">peek_tt_pound</a></li><li><a href="#method.peek_tt_question" title="peek_tt_question">peek_tt_question</a></li><li><a href="#method.peek_tt_r_arrow" title="peek_tt_r_arrow">peek_tt_r_arrow</a></li><li><a href="#method.peek_tt_semi" title="peek_tt_semi">peek_tt_semi</a></li><li><a href="#method.peek_tt_shl" title="peek_tt_shl">peek_tt_shl</a></li><li><a href="#method.peek_tt_shl_eq" title="peek_tt_shl_eq">peek_tt_shl_eq</a></li><li><a href="#method.peek_tt_shr" title="peek_tt_shr">peek_tt_shr</a></li><li><a href="#method.peek_tt_shr_eq" title="peek_tt_shr_eq">peek_tt_shr_eq</a></li><li><a href="#method.peek_tt_slash" title="peek_tt_slash">peek_tt_slash</a></li><li><a href="#method.peek_tt_slash_eq" title="peek_tt_slash_eq">peek_tt_slash_eq</a></li><li><a href="#method.peek_tt_star" title="peek_tt_star">peek_tt_star</a></li><li><a href="#method.peek_tt_star_eq" title="peek_tt_star_eq">peek_tt_star_eq</a></li><li><a href="#method.peek_tt_tilde" title="peek_tt_tilde">peek_tt_tilde</a></li><li><a href="#method.span" title="span">span</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-TokenParser%3CI,+PEEKER_LEN%3E" title="Clone">Clone</a></li><li><a href="#impl-From%3CT%3E-for-TokenParser%3CI,+PEEKER_LEN%3E" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-From%3CTokenParser%3CI,+PEEKER_LEN%3E%3E-for-TokenStream" title="From&#60;TokenParser&#60;I, PEEKER_LEN&#62;&#62;">From&#60;TokenParser&#60;I, PEEKER_LEN&#62;&#62;</a></li><li><a href="#impl-FromStr-for-TokenParser" title="FromStr">FromStr</a></li><li><a href="#impl-Iterator-for-TokenParser%3CI,+PEEKER_LEN%3E" title="Iterator">Iterator</a></li><li><a href="#impl-ToTokens-for-TokenParser%3CI,+PEEKER_LEN%3E" title="ToTokens">ToTokens</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Send-for-TokenParser%3CI,+PEEKER_LEN%3E" title="!Send">!Send</a></li><li><a href="#impl-Sync-for-TokenParser%3CI,+PEEKER_LEN%3E" title="!Sync">!Sync</a></li><li><a href="#impl-Freeze-for-TokenParser%3CI,+PEEKER_LEN%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-TokenParser%3CI,+PEEKER_LEN%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoIterator-for-I" title="IntoIterator">IntoIterator</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate proc_<wbr>macro_<wbr>utils</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">proc_macro_utils</a></span><h1>Struct <span class="struct">TokenParser</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/proc_macro_utils/parser.rs.html#109-115">source</a> </span></div><pre class="rust item-decl"><code>pub struct TokenParser&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt; = <a class="struct" href="../proc_macro2/token_stream/struct.IntoIter.html" title="struct proc_macro2::token_stream::IntoIter">IntoIter</a>, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a> = 6&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wrapper for <a href="../proc_macro2/struct.TokenStream.html#method.into_iter" title="method proc_macro2::TokenStream::into_iter"><code>TokenStream::into_iter</code></a> allowing not only to iterate on
tokens but also to parse simple structures like types or expressions, though
it does not make any claims about their correctness.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>token_parser = TokenParser::new(<span class="macro">quote!</span> {a + b, c});
<span class="macro">assert_tokens!</span>(token_parser.next_expression().unwrap(), { a + b });</code></pre></div>
<h2 id="construction"><a class="doc-anchor" href="#construction">§</a>Construction</h2>
<p>In most cases use <a href="struct.TokenParser.html#method.new" title="associated function proc_macro_utils::TokenParser::new"><code>new()</code></a> to avoid specifying the
generics. To change the on-stack size of the peek-buffer use
<a href="struct.TokenParser.html#method.new_generic" title="associated function proc_macro_utils::TokenParser::new_generic"><code>new_generic()</code></a> or
<a href="#impl-From%3CT%3E-for-TokenParser%3CI,+PEEKER_LEN%3E"><code>From::from</code></a>.</p>
<h2 id="peeking"><a class="doc-anchor" href="#peeking">§</a>Peeking</h2>
<p>The <code>TokenParser</code> allows peeking an arbitrary amount of tokens using
<a href="struct.TokenParser.html#method.peek_n" title="method proc_macro_utils::TokenParser::peek_n"><code>peek_n()</code></a> and the token specific variants. This uses a
<a href="../smallvec/struct.SmallVec.html" title="struct smallvec::SmallVec"><code>SmallVec</code></a> with its capacity specified via <code>PEEKER_LEN</code> (default is 6).
This means peeking up to <code>6</code> tokens ahead happens without heap allocation.
Token groups can need up to <code>3</code> tokens of additional space e.g.
<a href="struct.TokenParser.html#method.peek_n_tt_dot_dot_eq" title="method proc_macro_utils::TokenParser::peek_n_tt_dot_dot_eq"><code>peek_n_tt_dot_dot_eq()</code></a> can, with the default
allocation free be called with up to <code>3</code>, and
<a href="struct.TokenParser.html#method.peek_n_tt_plus_eq" title="method proc_macro_utils::TokenParser::peek_n_tt_plus_eq"><code>peek_n_tt_plus_eq()</code></a> up to <code>4</code>.</p>
<p><strong>Warning</strong>: Setting <code>PEEKER_LEN = 0</code> means even
<a href="struct.TokenParser.html#method.is_empty" title="method proc_macro_utils::TokenParser::is_empty"><code>is_empty()</code></a> and <a href="struct.TokenParser.html#method.peek" title="method proc_macro_utils::TokenParser::peek"><code>peek()</code></a> allocate, and a
value below <code>3</code> will make some of the
<a href="#impl-TokenParser%3CI,+PEEKER_LEN%3E-3"><code>peek_{punctuation}</code></a> allocate
additionally. But do also refrain from setting <code>PEEKER_LEN</code> too high, as
this is the stack allocation used.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-TokenParser" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#117-144">source</a><a href="#impl-TokenParser" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#122-128">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;T, I&gt;(value: T) -&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, 6&gt; <a href="#" class="tooltip" data-notable-ty="TokenParser&lt;I, 6&gt;">ⓘ</a><div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>, IntoIter = I&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a new <a href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser"><code>TokenParser</code></a> from a <a href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree"><code>TokenTree</code></a> iterator.</p>
<p>This sets the default length for the peeker buffer. Use
<a href="struct.TokenParser.html#method.new_generic" title="associated function proc_macro_utils::TokenParser::new_generic"><code>new_generic()</code></a> to change it.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_generic" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#134-143">source</a><h4 class="code-header">pub fn <a href="#method.new_generic" class="fn">new_generic</a>&lt;const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>, T, I&gt;(
    value: T,
) -&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt; <a href="#" class="tooltip" data-notable-ty="TokenParser&lt;I, PEEKER_LEN&gt;">ⓘ</a><div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>, IntoIter = I&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a new <a href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser"><code>TokenParser</code></a> from a <a href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree"><code>TokenTree</code></a> iterator, allowing
to specify the size of the peeker buffer.</p>
<p>See <a href="#Peeking">Peeking</a> for implications.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#361-729">source</a><a href="#impl-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="docblock"><p>Some Iterator utilities</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.span" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#367-369">source</a><h4 class="code-header">pub fn <a href="#method.span" class="fn">span</a>(&amp;mut self) -&gt; <a class="struct" href="../proc_macro2/struct.Span.html" title="struct proc_macro2::Span">Span</a></h4></section></summary><div class="docblock"><p>Returns span of the next token or <a href="../proc_macro2/struct.Span.html#method.call_site" title="associated function proc_macro2::Span::call_site"><code>Span::call_site()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#382-384">source</a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if there are remaining tokens</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::TokenParser;
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(token));
<span class="macro">assert!</span>(!parser.is_empty());
<span class="kw">_ </span>= parser.next();
<span class="macro">assert!</span>(parser.is_empty())</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#397-402">source</a><h4 class="code-header">pub fn <a href="#method.peek" class="fn">peek</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;</h4></section></summary><div class="docblock"><p>Peeks the next token without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(token));
<span class="macro">assert_tokens!</span>(parser.peek().cloned(), { token });
<span class="kw">_ </span>= parser.next();
<span class="macro">assert!</span>(parser.peek().is_none())</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#415-420">source</a><h4 class="code-header">pub fn <a href="#method.peek_n" class="fn">peek_n</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;</h4></section></summary><div class="docblock"><p>Peeks the <code>n</code>th token without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(token , third));
<span class="macro">assert_tokens!</span>(parser.peek_n(<span class="number">2</span>).cloned(), { third });
<span class="macro">assert_tokens!</span>(parser.peek_n(<span class="number">1</span>).cloned(), { , });
<span class="macro">assert!</span>(parser.peek_n(<span class="number">3</span>).is_none())</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_if" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#435-437">source</a><h4 class="code-header">pub fn <a href="#method.next_if" class="fn">next_if</a>(
    &amp;mut self,
    test: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it fulfills the condition otherwise returns
None and doesn’t advance the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser, TokenTreePunct};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(::));
<span class="macro">assert!</span>(parser.next_if(TokenTreePunct::is_alone).is_none());
<span class="kw">_ </span>= parser.next();
<span class="macro">assert_tokens!</span>(parser.next_if(TokenTreePunct::is_alone), { : });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_if_each" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#451-458">source</a><h4 class="code-header">pub fn <a href="#method.next_if_each" class="fn">next_if_each</a>&lt;P: Peeker&gt;(&amp;mut self, tests: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next tokens if they fulfill the conditions
otherwise returns None and doesn’t advance the parser.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser, TokenTreePunct};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>( --&gt;));
<span class="macro">assert!</span>(parser.next_if_each((TokenTreePunct::is_minus, TokenTreePunct::is_greater_than)).is_none());
<span class="kw">_ </span>= parser.next();
<span class="macro">assert_tokens!</span>(parser.next_if_each((TokenTreePunct::is_minus, TokenTreePunct::is_greater_than)).unwrap(), { -&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_if_each_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#465-475">source</a><h4 class="code-header">pub fn <a href="#method.next_if_each_alone" class="fn">next_if_each_alone</a>&lt;P: Peeker&gt;(&amp;mut self, tests: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next tokens if they fulfill the conditions
otherwise returns None and doesn’t advance the parser. If the last token
is a punct it’s <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to
<a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_if_each" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#480-483">source</a><h4 class="code-header">pub fn <a href="#method.peek_if_each" class="fn">peek_if_each</a>&lt;P: Peeker&gt;(&amp;mut self, tests: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next tokens if they fulfill the conditions
otherwise returns None, without advancing the parser</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_if_each" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#488-494">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_if_each" class="fn">peek_n_if_each</a>&lt;P: Peeker&gt;(
    &amp;mut self,
    n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>,
    tests: P,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next tokens from <code>n</code> if they fulfill the
conditions otherwise returns None, without advancing the parser</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_if_each_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#501-516">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_if_each_alone" class="fn">peek_n_if_each_alone</a>&lt;P: Peeker&gt;(
    &amp;mut self,
    n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>,
    tests: P,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next tokens from <code>n</code> if they fulfill the conditions
otherwise returns None, without advancing the parser. If the last token
is a punct it’s <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to
<a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_while" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#523-534">source</a><h4 class="code-header">pub fn <a href="#method.next_while" class="fn">next_while</a>(
    &amp;mut self,
    test: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns all tokens while <code>test</code> evaluates to true.</p>
<p>Returns <code>None</code> if empty or <code>test(first_token) == false</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_while_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#543-558">source</a><h4 class="code-header">pub fn <a href="#method.next_while_alone" class="fn">next_while_alone</a>(
    &amp;mut self,
    test: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns all tokens while <code>test</code> evaluates to true. If the last token
is a punct it’s <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to
<a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
<p>Returns <code>None</code> if empty or <code>test(first_token) == false</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_until" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#564-566">source</a><h4 class="code-header">pub fn <a href="#method.next_until" class="fn">next_until</a>(
    &amp;mut self,
    test: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns all tokens while <code>test</code> evaluates to false.</p>
<p>Returns <code>None</code> if empty or <code>test(first_token) == true</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_until_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#574-579">source</a><h4 class="code-header">pub fn <a href="#method.next_until_alone" class="fn">next_until_alone</a>(
    &amp;mut self,
    test: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns all tokens while <code>test</code> evaluates to false. If the last token is
a punct it’s <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to
<a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
<p>Returns <code>None</code> if empty or <code>test(first_token) == true</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_n" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#601-603">source</a><h4 class="code-header">pub fn <a href="#method.next_n" class="fn">next_n</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next <code>n</code> tokens.</p>
<p>Returns <code>None</code> if the parser contains less than <code>n</code> tokens.</p>
<p><strong>Note:</strong> This should only be used for small <code>n</code> ideally less than
<code>PEEKER_LEN</code>. Otherwise, something like this would be more performant:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro2::TokenStream;
<span class="kw">use </span>proc_macro_utils::{TokenParser, assert_tokens};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="number">1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003</span>));
<span class="kw">let </span>n = <span class="number">1000</span>;
<span class="comment">// This does not ensure that `next_up_to_n` contains exactly n tokens
</span><span class="kw">let </span>next_up_to_n: TokenStream = parser.by_ref().take(n).collect();
<span class="macro">assert_tokens!</span>(next_up_to_n, { <span class="number">1 2 3 </span><span class="comment">/* ...*/ </span><span class="number">1000 </span>});
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1001 1002 1003 </span>});</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_n_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#627-629">source</a><h4 class="code-header">pub fn <a href="#method.next_n_alone" class="fn">next_n_alone</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next <code>n</code> tokens. If the last token is a punct it’s
<a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to <a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
<p>Returns <code>None</code> if the parser contains less than <code>n</code> tokens.</p>
<p><strong>Note:</strong> This should only be used for small <code>n</code> ideally less than
<code>PEEKER_LEN</code>. Otherwise, something like this would be more performant:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro2::TokenStream;
<span class="kw">use </span>proc_macro_utils::{TokenParser, assert_tokens, TokenTreePunct};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="number">1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003</span>));
<span class="kw">let </span>n = <span class="number">1000</span>;
<span class="comment">// This does not ensure that `next_up_to_n` contains exactly n tokens
</span><span class="kw">let </span><span class="kw-2">mut </span>next_up_to_n: TokenStream = parser.by_ref().take(n - <span class="number">1</span>).collect();
next_up_to_n.extend(parser.next().map(TokenTreePunct::alone));
<span class="macro">assert_tokens!</span>(next_up_to_n, { <span class="number">1 2 3 </span><span class="comment">/* ...*/ </span><span class="number">1000 </span>});
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1001 1002 1003 </span>});</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_range" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#659-676">source</a><h4 class="code-header">pub fn <a href="#method.peek_range" class="fn">peek_range</a>(
    &amp;mut self,
    range: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the specified <code>range</code> of tokens.</p>
<p>Returns <code>None</code> if the parser does not contain these <code>range</code> tokens.</p>
<p><strong>Note:</strong> This should only be used for small and close to start <code>range</code>s
ideally less than <code>PEEKER_LEN</code>. Otherwise, something like this could be
more performant:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro2::TokenStream;
<span class="kw">use </span>proc_macro_utils::{TokenParser, assert_tokens};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="number">0 1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003</span>));
<span class="kw">let </span>start = <span class="number">1000</span>;
<span class="kw">let </span>end = <span class="number">1003</span>;
<span class="comment">// This does not ensure that `peeked_range` contains any tokens
</span><span class="kw">let </span>peeked_range: TokenStream = parser.clone().skip(start).take(end -
start).collect();
<span class="macro">assert_tokens!</span>(peeked_range, { <span class="number">1000 1001 1002 </span>});
<span class="macro">assert_tokens!</span>(parser, { <span class="number">0 1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003 </span>});</code></pre></div>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if used without upper bound i.e. <code>start..</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_range_alone" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#711-728">source</a><h4 class="code-header">pub fn <a href="#method.peek_range_alone" class="fn">peek_range_alone</a>(
    &amp;mut self,
    range: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the specified <code>range</code> of tokens. If the last token is a punct
it’s <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>spacing</code></a> is set to
<a href="../proc_macro2/enum.Spacing.html#variant.Alone" title="variant proc_macro2::Spacing::Alone"><code>Alone</code></a>.</p>
<p>Returns <code>None</code> if the parser does not contain these <code>range</code> tokens.</p>
<p><strong>Note:</strong> This should only be used for small and close to start <code>range</code>s
ideally less than <code>PEEKER_LEN</code>. Otherwise, something like this could be
more performant:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro2::TokenStream;
<span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser, TokenTreePunct};
<span class="kw">use </span>quote::quote;

<span class="kw">let </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="number">0 1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003</span>));
<span class="kw">let </span>start = <span class="number">1000</span>;
<span class="kw">let </span>end = <span class="number">1003</span>;
<span class="comment">// This does not ensure that `peeked_range` contains any tokens
</span><span class="kw">let </span><span class="kw-2">mut </span>cloned = parser.clone().skip(start);
<span class="kw">let </span><span class="kw-2">mut </span>peeked_range: TokenStream = cloned.by_ref().take(end - start - <span class="number">1</span>).collect();
peeked_range.extend(cloned.next().map(TokenTreePunct::alone));

<span class="macro">assert_tokens!</span>(peeked_range, { <span class="number">1000 1001 1002 </span>});
<span class="macro">assert_tokens!</span>(parser, { <span class="number">0 1 2 3 </span><span class="comment">/*...*/ </span><span class="number">1000 1001 1002 1003 </span>});</code></pre></div>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if used without upper bound i.e. <code>start..</code>.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TokenParser%3CI,+PEEKER_LEN%3E-1" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#731-973">source</a><a href="#impl-TokenParser%3CI,+PEEKER_LEN%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_token_stream" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#737-739">source</a><h4 class="code-header">pub fn <a href="#method.into_token_stream" class="fn">into_token_stream</a>(self) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class="docblock"><p>Collects remaining tokens back into a <a href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream"><code>TokenStream</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_punctuation_group" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#744-751">source</a><h4 class="code-header">pub fn <a href="#method.next_punctuation_group" class="fn">next_punctuation_group</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next group of punctuation with <a href="../proc_macro2/struct.Punct.html#method.spacing" title="method proc_macro2::Punct::spacing"><code>Punct::spacing</code></a>
<a href="../proc_macro2/enum.Spacing.html#variant.Joint" title="variant proc_macro2::Spacing::Joint"><code>Spacing::Joint</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_keyword" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#769-774">source</a><h4 class="code-header">pub fn <a href="#method.peek_keyword" class="fn">peek_keyword</a>&lt;K: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;mut self, keyword: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;<div class="where">where
    <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;K&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the next ident if it matches the specified keyword without
advancing the parser.</p>
<p>While this is called <code>peek_keyword</code> it is not restricted to rust
keywords, it can be used with any ident.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>( <span class="kw">in </span>out ));
<span class="macro">assert_eq!</span>(parser.peek_keyword(<span class="string">"in"</span>).unwrap().to_string(), <span class="string">"in"</span>);
<span class="macro">assert_eq!</span>(parser.peek_keyword(<span class="string">"in"</span>).unwrap().to_string(), <span class="string">"in"</span>);
<span class="macro">assert!</span>(parser.peek_keyword(<span class="string">"out"</span>).is_none());
parser.next().unwrap();
<span class="macro">assert_eq!</span>(parser.peek_keyword(<span class="string">"out"</span>).unwrap().to_string(), <span class="string">"out"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_keyword" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#790-795">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_keyword" class="fn">peek_n_keyword</a>&lt;K: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(
    &amp;mut self,
    n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>,
    keyword: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;K</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;<div class="where">where
    <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;K&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the nth token if it matches the specified keyword without
advancing the parser.</p>
<p>While this is called <code>peek_n_keyword</code> it is not restricted to rust
keywords, it can be used with any ident.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>( <span class="kw">in </span>out ));
<span class="macro">assert_eq!</span>(parser.peek_keyword(<span class="string">"in"</span>).unwrap().to_string(), <span class="string">"in"</span>);
<span class="macro">assert_eq!</span>(parser.peek_n_keyword(<span class="number">1</span>, <span class="string">"out"</span>).unwrap().to_string(), <span class="string">"out"</span>);
<span class="macro">assert!</span>(parser.peek_keyword(<span class="string">"out"</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_keyword" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#812-818">source</a><h4 class="code-header">pub fn <a href="#method.next_keyword" class="fn">next_keyword</a>&lt;K: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt;(&amp;mut self, keyword: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;<div class="where">where
    <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;K&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the next ident if it matches the specified keyword.</p>
<p>While this is called <code>next_keyword</code> it is not restricted to rust
keywords, it can be used with any ident.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>( <span class="kw">in </span>out ));
<span class="macro">assert_eq!</span>(parser.next_keyword(<span class="string">"in"</span>).unwrap().to_string(), <span class="string">"in"</span>);
<span class="macro">assert!</span>(parser.next_keyword(<span class="string">"in"</span>).is_none());
<span class="macro">assert_eq!</span>(parser.next_keyword(<span class="string">"out"</span>).unwrap().to_string(), <span class="string">"out"</span>);
<span class="macro">assert!</span>(parser.next_keyword(<span class="string">"anything"</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_type" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#843-862">source</a><h4 class="code-header">pub fn <a href="#method.next_type" class="fn">next_type</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>“Parses” a type expression</p>
<p>This just means it collects all the tokens that should belong to the
type, until it reaches either:</p>
<ul>
<li>a <code>;</code></li>
<li>a <code>,</code> or <code>&gt;</code> and all <code>&lt;&gt;</code> pairs are closed</li>
<li>the end of the token stream</li>
</ul>
<p>If the token stream is empty, or starts with <code>,</code>, <code>&gt;</code> or <code>;</code> <a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> is
returned otherwise, <a href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream"><code>Some(TokenStream)</code></a> containing
every token up to but excluding the terminator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span><span class="kw-2">mut </span>tokens = TokenParser::new(<span class="macro">quote!</span> {A&lt;Test, B&gt;, remainder});
<span class="macro">assert_tokens!</span>(tokens.next_type().unwrap(), { A&lt;Test, B&gt; });
<span class="macro">assert!</span>(tokens.next_type().is_none());
<span class="macro">assert_tokens!</span>(tokens, { , remainder });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_expression" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#889-954">source</a><h4 class="code-header">pub fn <a href="#method.next_expression" class="fn">next_expression</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>“Parses” an expression</p>
<p>This just means it collects all the tokens that should belong to the
expression, until it reaches (outside a group like <code>()</code> or <code>{}</code>) either:</p>
<ul>
<li>a <code>=&gt;</code></li>
<li>a <code>;</code></li>
<li>a <code>,</code> outside a type</li>
<li>the end of the token stream</li>
</ul>
<p>If the token stream is empty, or starts with <code>=&gt;</code>, <code>,</code> or <code>;</code> <a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>
is returned otherwise, <a href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream"><code>Some(TokenStream)</code></a> containing
every token up to but excluding the terminator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">let </span><span class="kw-2">mut </span>tokens = TokenParser::new(<span class="macro">quote!</span> {A + c ::&lt;a, b&gt;::a &lt; b + &lt;C <span class="kw">as </span>Trait&lt;A, B&gt;::C&gt;::nice(), next_token});
<span class="macro">assert_tokens!</span>(tokens.next_expression().unwrap(), { A + c::&lt;a, b&gt;::a &lt; b + &lt;C <span class="kw">as </span>Trait&lt;A, B&gt;::C&gt;::nice()});
<span class="macro">assert!</span>(tokens.next_expression().is_none());
<span class="macro">assert_tokens!</span>(tokens, { , next_token });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_string" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#958-962">source</a><h4 class="code-header">pub fn <a href="#method.next_string" class="fn">next_string</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.83.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next string literal</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_bool" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#966-972">source</a><h4 class="code-header">pub fn <a href="#method.next_bool" class="fn">next_bool</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next boolean literal</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TokenParser%3CI,+PEEKER_LEN%3E-2" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#975-991">source</a><a href="#impl-TokenParser%3CI,+PEEKER_LEN%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.next_group" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.next_group" class="fn">next_group</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group"><code>Group</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_ident" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.next_ident" class="fn">next_ident</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is an <a href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident"><code>Ident</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_punct" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.next_punct" class="fn">next_punct</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct">Punct</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct"><code>Punct</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_literal" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.next_literal" class="fn">next_literal</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal">Literal</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal"><code>Literal</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_group" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_group" class="fn">peek_group</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group"><code>Group</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_ident" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_ident" class="fn">peek_ident</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is an <a href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident"><code>Ident</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_punct" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_punct" class="fn">peek_punct</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct">Punct</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct"><code>Punct</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_literal" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_literal" class="fn">peek_literal</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal">Literal</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal"><code>Literal</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_group" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_group" class="fn">peek_n_group</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group"><code>Group</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_ident" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_ident" class="fn">peek_n_ident</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is an <a href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident"><code>Ident</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_punct" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_punct" class="fn">peek_n_punct</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct">Punct</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="../proc_macro2/struct.Punct.html" title="struct proc_macro2::Punct"><code>Punct</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_literal" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#979-984">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_literal" class="fn">peek_n_literal</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal">Literal</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="../proc_macro2/struct.Literal.html" title="struct proc_macro2::Literal"><code>Literal</code></a> without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_parenthesized" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.next_parenthesized" class="fn">next_parenthesized</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a parenthesized group.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_braced" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.next_braced" class="fn">next_braced</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a braced group.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_bracketed" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.next_bracketed" class="fn">next_bracketed</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a bracketed group.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_parenthesized" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_parenthesized" class="fn">peek_parenthesized</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is aparenthesized group, without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_braced" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_braced" class="fn">peek_braced</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is abraced group, without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_bracketed" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_bracketed" class="fn">peek_bracketed</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is abracketed group, without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_parenthesized" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_parenthesized" class="fn">peek_n_parenthesized</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a parenthesized group, without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_braced" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_braced" class="fn">peek_n_braced</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a braced group, without advancing the parser.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_bracketed" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#986-990">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_bracketed" class="fn">peek_n_bracketed</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../proc_macro2/struct.Group.html" title="struct proc_macro2::Group">Group</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a bracketed group, without advancing the parser.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TokenParser%3CI,+PEEKER_LEN%3E-3" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1000-1101">source</a><a href="#impl-TokenParser%3CI,+PEEKER_LEN%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="docblock"><p>For now the naming of the tokens follow the names used in the
<a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">rust reference</a>
even though they diverge from the names used at <a href="trait.TokenTreePunct.html" title="trait proc_macro_utils::TokenTreePunct"><code>TokenTreePunct</code></a>.</p>
<p>Note that they only match the token with correct <a href="../proc_macro2/enum.Spacing.html" title="enum proc_macro2::Spacing">spacing</a>, i.e.
<a href="struct.TokenParser.html#method.next_tt_plus" title="method proc_macro_utils::TokenParser::next_tt_plus"><code>next_plus</code></a> will match <code>+ =</code> and <code>+a</code> but not <code>+=</code>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.next_tt_plus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_plus" class="fn">next_tt_plus</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(+ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_plus().unwrap(), { + });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_plus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_plus" class="fn">peek_tt_plus</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(+ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_plus().unwrap(), { + });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_plus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_plus" class="fn">peek_n_tt_plus</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b + <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_plus(<span class="number">1</span>).unwrap(), { + });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_minus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_minus" class="fn">next_tt_minus</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(- <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_minus().unwrap(), { - });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_minus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_minus" class="fn">peek_tt_minus</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(- <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_minus().unwrap(), { - });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_minus" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_minus" class="fn">peek_n_tt_minus</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b - <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_minus(<span class="number">1</span>).unwrap(), { - });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_star" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_star" class="fn">next_tt_star</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(* <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_star().unwrap(), { * });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_star" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_star" class="fn">peek_tt_star</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(* <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_star().unwrap(), { * });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_star" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_star" class="fn">peek_n_tt_star</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b * <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_star(<span class="number">1</span>).unwrap(), { * });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_slash" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_slash" class="fn">next_tt_slash</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(/ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_slash().unwrap(), { / });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_slash" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_slash" class="fn">peek_tt_slash</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(/ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_slash().unwrap(), { / });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_slash" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_slash" class="fn">peek_n_tt_slash</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b / <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_slash(<span class="number">1</span>).unwrap(), { / });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_percent" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_percent" class="fn">next_tt_percent</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(% <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_percent().unwrap(), { % });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_percent" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_percent" class="fn">peek_tt_percent</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(% <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_percent().unwrap(), { % });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_percent" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_percent" class="fn">peek_n_tt_percent</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b % <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_percent(<span class="number">1</span>).unwrap(), { % });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_caret" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_caret" class="fn">next_tt_caret</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(^ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_caret().unwrap(), { ^ });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_caret" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_caret" class="fn">peek_tt_caret</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(^ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_caret().unwrap(), { ^ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_caret" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_caret" class="fn">peek_n_tt_caret</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ^ <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_caret(<span class="number">1</span>).unwrap(), { ^ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_not" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_not" class="fn">next_tt_not</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(! <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_not().unwrap(), { ! });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_not" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_not" class="fn">peek_tt_not</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(! <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_not().unwrap(), { ! });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_not" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_not" class="fn">peek_n_tt_not</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ! <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_not(<span class="number">1</span>).unwrap(), { ! });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_and" class="fn">next_tt_and</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_and().unwrap(), { &amp; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_and" class="fn">peek_tt_and</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_and().unwrap(), { &amp; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_and" class="fn">peek_n_tt_and</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &amp; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_and(<span class="number">1</span>).unwrap(), { &amp; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_or" class="fn">next_tt_or</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(| <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_or().unwrap(), { | });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_or" class="fn">peek_tt_or</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(| <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_or().unwrap(), { | });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_or" class="fn">peek_n_tt_or</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b | <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_or(<span class="number">1</span>).unwrap(), { | });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_and_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_and_and" class="fn">next_tt_and_and</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp;&amp; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_and_and().unwrap(), { &amp;&amp; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_and_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_and_and" class="fn">peek_tt_and_and</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp;&amp; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_and_and().unwrap(), { &amp;&amp; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_and_and" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_and_and" class="fn">peek_n_tt_and_and</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;&amp;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &amp;&amp; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_and_and(<span class="number">1</span>).unwrap(), { &amp;&amp; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_or_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_or_or" class="fn">next_tt_or_or</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>||</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(|| <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_or_or().unwrap(), { || });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_or_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_or_or" class="fn">peek_tt_or_or</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>||</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(|| <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_or_or().unwrap(), { || });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_or_or" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_or_or" class="fn">peek_n_tt_or_or</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>||</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b || <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_or_or(<span class="number">1</span>).unwrap(), { || });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_shl" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_shl" class="fn">next_tt_shl</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;&lt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_shl().unwrap(), { &lt;&lt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_shl" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_shl" class="fn">peek_tt_shl</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;&lt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_shl().unwrap(), { &lt;&lt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_shl" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_shl" class="fn">peek_n_tt_shl</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &lt;&lt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_shl(<span class="number">1</span>).unwrap(), { &lt;&lt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_shr" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_shr" class="fn">next_tt_shr</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_shr().unwrap(), { &gt;&gt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_shr" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_shr" class="fn">peek_tt_shr</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_shr().unwrap(), { &gt;&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_shr" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_shr" class="fn">peek_n_tt_shr</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &gt;&gt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_shr(<span class="number">1</span>).unwrap(), { &gt;&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_plus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_plus_eq" class="fn">next_tt_plus_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(+= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_plus_eq().unwrap(), { += });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_plus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_plus_eq" class="fn">peek_tt_plus_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(+= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_plus_eq().unwrap(), { += });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_plus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_plus_eq" class="fn">peek_n_tt_plus_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>+=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b += <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_plus_eq(<span class="number">1</span>).unwrap(), { += });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_minus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_minus_eq" class="fn">next_tt_minus_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(-= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_minus_eq().unwrap(), { -= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_minus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_minus_eq" class="fn">peek_tt_minus_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(-= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_minus_eq().unwrap(), { -= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_minus_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_minus_eq" class="fn">peek_n_tt_minus_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b -= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_minus_eq(<span class="number">1</span>).unwrap(), { -= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_star_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_star_eq" class="fn">next_tt_star_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="kw-2">*</span>= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_star_eq().unwrap(), { <span class="kw-2">*</span>= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_star_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_star_eq" class="fn">peek_tt_star_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="kw-2">*</span>= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_star_eq().unwrap(), { <span class="kw-2">*</span>= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_star_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_star_eq" class="fn">peek_n_tt_star_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>*=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b <span class="kw-2">*</span>= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_star_eq(<span class="number">1</span>).unwrap(), { <span class="kw-2">*</span>= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_slash_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_slash_eq" class="fn">next_tt_slash_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(/= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_slash_eq().unwrap(), { /= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_slash_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_slash_eq" class="fn">peek_tt_slash_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(/= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_slash_eq().unwrap(), { /= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_slash_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_slash_eq" class="fn">peek_n_tt_slash_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>/=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b /= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_slash_eq(<span class="number">1</span>).unwrap(), { /= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_percent_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_percent_eq" class="fn">next_tt_percent_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(%= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_percent_eq().unwrap(), { %= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_percent_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_percent_eq" class="fn">peek_tt_percent_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(%= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_percent_eq().unwrap(), { %= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_percent_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_percent_eq" class="fn">peek_n_tt_percent_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>%=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b %= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_percent_eq(<span class="number">1</span>).unwrap(), { %= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_caret_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_caret_eq" class="fn">next_tt_caret_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(^= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_caret_eq().unwrap(), { ^= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_caret_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_caret_eq" class="fn">peek_tt_caret_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(^= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_caret_eq().unwrap(), { ^= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_caret_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_caret_eq" class="fn">peek_n_tt_caret_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>^=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ^= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_caret_eq(<span class="number">1</span>).unwrap(), { ^= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_and_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_and_eq" class="fn">next_tt_and_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_and_eq().unwrap(), { &amp;= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_and_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_and_eq" class="fn">peek_tt_and_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&amp;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_and_eq().unwrap(), { &amp;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_and_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_and_eq" class="fn">peek_n_tt_and_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&amp;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &amp;= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_and_eq(<span class="number">1</span>).unwrap(), { &amp;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_or_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_or_eq" class="fn">next_tt_or_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(|= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_or_eq().unwrap(), { |= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_or_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_or_eq" class="fn">peek_tt_or_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(|= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_or_eq().unwrap(), { |= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_or_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_or_eq" class="fn">peek_n_tt_or_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>|=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b |= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_or_eq(<span class="number">1</span>).unwrap(), { |= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_shl_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_shl_eq" class="fn">next_tt_shl_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;&lt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_shl_eq().unwrap(), { &lt;&lt;= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_shl_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_shl_eq" class="fn">peek_tt_shl_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;&lt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_shl_eq().unwrap(), { &lt;&lt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_shl_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_shl_eq" class="fn">peek_n_tt_shl_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &lt;&lt;= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_shl_eq(<span class="number">1</span>).unwrap(), { &lt;&lt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_shr_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_shr_eq" class="fn">next_tt_shr_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;&gt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_shr_eq().unwrap(), { &gt;&gt;= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_shr_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_shr_eq" class="fn">peek_tt_shr_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;&gt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_shr_eq().unwrap(), { &gt;&gt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_shr_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_shr_eq" class="fn">peek_n_tt_shr_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &gt;&gt;= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_shr_eq(<span class="number">1</span>).unwrap(), { &gt;&gt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_eq" class="fn">next_tt_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_eq().unwrap(), { = });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_eq" class="fn">peek_tt_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_eq().unwrap(), { = });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_eq" class="fn">peek_n_tt_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b = <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_eq(<span class="number">1</span>).unwrap(), { = });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_eq_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_eq_eq" class="fn">next_tt_eq_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>==</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(== <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_eq_eq().unwrap(), { == });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_eq_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_eq_eq" class="fn">peek_tt_eq_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>==</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(== <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_eq_eq().unwrap(), { == });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_eq_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_eq_eq" class="fn">peek_n_tt_eq_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>==</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b == <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_eq_eq(<span class="number">1</span>).unwrap(), { == });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_ne" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_ne" class="fn">next_tt_ne</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(!= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_ne().unwrap(), { != });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_ne" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_ne" class="fn">peek_tt_ne</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(!= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_ne().unwrap(), { != });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_ne" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_ne" class="fn">peek_n_tt_ne</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>!=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b != <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_ne(<span class="number">1</span>).unwrap(), { != });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_gt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_gt" class="fn">next_tt_gt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_gt().unwrap(), { &gt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_gt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_gt" class="fn">peek_tt_gt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_gt().unwrap(), { &gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_gt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_gt" class="fn">peek_n_tt_gt</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &gt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_gt(<span class="number">1</span>).unwrap(), { &gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_lt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_lt" class="fn">next_tt_lt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_lt().unwrap(), { &lt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_lt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_lt" class="fn">peek_tt_lt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_lt().unwrap(), { &lt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_lt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_lt" class="fn">peek_n_tt_lt</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &lt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_lt(<span class="number">1</span>).unwrap(), { &lt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_ge" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_ge" class="fn">next_tt_ge</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_ge().unwrap(), { &gt;= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_ge" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_ge" class="fn">peek_tt_ge</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&gt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_ge().unwrap(), { &gt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_ge" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_ge" class="fn">peek_n_tt_ge</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&gt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &gt;= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_ge(<span class="number">1</span>).unwrap(), { &gt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_le" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_le" class="fn">next_tt_le</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_le().unwrap(), { &lt;= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_le" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_le" class="fn">peek_tt_le</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(&lt;= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_le().unwrap(), { &lt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_le" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_le" class="fn">peek_n_tt_le</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>&lt;=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b &lt;= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_le(<span class="number">1</span>).unwrap(), { &lt;= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_at" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_at" class="fn">next_tt_at</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>@</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(@ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_at().unwrap(), { @ });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_at" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_at" class="fn">peek_tt_at</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>@</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(@ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_at().unwrap(), { @ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_at" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_at" class="fn">peek_n_tt_at</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>@</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b @ <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_at(<span class="number">1</span>).unwrap(), { @ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_dot" class="fn">next_tt_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>.</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(. <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_dot().unwrap(), { . });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_dot" class="fn">peek_tt_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>.</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(. <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_dot().unwrap(), { . });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_dot" class="fn">peek_n_tt_dot</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>.</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b . <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_dot(<span class="number">1</span>).unwrap(), { . });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_dot_dot" class="fn">next_tt_dot_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(.. <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_dot_dot().unwrap(), { .. });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_dot_dot" class="fn">peek_tt_dot_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(.. <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_dot_dot().unwrap(), { .. });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_dot_dot" class="fn">peek_n_tt_dot_dot</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b .. <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_dot_dot(<span class="number">1</span>).unwrap(), { .. });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_dot_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_dot_dot_dot" class="fn">next_tt_dot_dot_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>...</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(... <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_dot_dot_dot().unwrap(), { ... });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_dot_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_dot_dot_dot" class="fn">peek_tt_dot_dot_dot</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>...</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(... <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_dot_dot_dot().unwrap(), { ... });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_dot_dot_dot" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_dot_dot_dot" class="fn">peek_n_tt_dot_dot_dot</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>...</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ... <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_dot_dot_dot(<span class="number">1</span>).unwrap(), { ... });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_dot_dot_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_dot_dot_eq" class="fn">next_tt_dot_dot_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(..= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_dot_dot_eq().unwrap(), { ..= });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_dot_dot_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_dot_dot_eq" class="fn">peek_tt_dot_dot_eq</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(..= <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_dot_dot_eq().unwrap(), { ..= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_dot_dot_eq" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_dot_dot_eq" class="fn">peek_n_tt_dot_dot_eq</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>..=</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ..= <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_dot_dot_eq(<span class="number">1</span>).unwrap(), { ..= });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_comma" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_comma" class="fn">next_tt_comma</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>,</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(, <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_comma().unwrap(), { , });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_comma" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_comma" class="fn">peek_tt_comma</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>,</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(, <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_comma().unwrap(), { , });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_comma" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_comma" class="fn">peek_n_tt_comma</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>,</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b , <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_comma(<span class="number">1</span>).unwrap(), { , });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_semi" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_semi" class="fn">next_tt_semi</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_semi().unwrap(), { ; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_semi" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_semi" class="fn">peek_tt_semi</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_semi().unwrap(), { ; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_semi" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_semi" class="fn">peek_n_tt_semi</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_semi(<span class="number">1</span>).unwrap(), { ; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_colon" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_colon" class="fn">next_tt_colon</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>:</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(: <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_colon().unwrap(), { : });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_colon" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_colon" class="fn">peek_tt_colon</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>:</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(: <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_colon().unwrap(), { : });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_colon" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_colon" class="fn">peek_n_tt_colon</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>:</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b : <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_colon(<span class="number">1</span>).unwrap(), { : });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_path_sep" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_path_sep" class="fn">next_tt_path_sep</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>::</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(:: <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_path_sep().unwrap(), { :: });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_path_sep" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_path_sep" class="fn">peek_tt_path_sep</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>::</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(:: <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_path_sep().unwrap(), { :: });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_path_sep" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_path_sep" class="fn">peek_n_tt_path_sep</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>::</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b :: <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_path_sep(<span class="number">1</span>).unwrap(), { :: });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_r_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_r_arrow" class="fn">next_tt_r_arrow</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(-&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_r_arrow().unwrap(), { -&gt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_r_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_r_arrow" class="fn">peek_tt_r_arrow</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(-&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_r_arrow().unwrap(), { -&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_r_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_r_arrow" class="fn">peek_n_tt_r_arrow</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>-&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b -&gt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_r_arrow(<span class="number">1</span>).unwrap(), { -&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_fat_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_fat_arrow" class="fn">next_tt_fat_arrow</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(=&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_fat_arrow().unwrap(), { =&gt; });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_fat_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_fat_arrow" class="fn">peek_tt_fat_arrow</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(=&gt; <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_fat_arrow().unwrap(), { =&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_fat_arrow" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_fat_arrow" class="fn">peek_n_tt_fat_arrow</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>=&gt;</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b =&gt; <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_fat_arrow(<span class="number">1</span>).unwrap(), { =&gt; });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_pound" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_pound" class="fn">next_tt_pound</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>#</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(# <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_pound().unwrap(), { # });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_pound" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_pound" class="fn">peek_tt_pound</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>#</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(# <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_pound().unwrap(), { # });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_pound" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_pound" class="fn">peek_n_tt_pound</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>#</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b # <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_pound(<span class="number">1</span>).unwrap(), { # });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_dollar" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_dollar" class="fn">next_tt_dollar</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>$</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>($ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_dollar().unwrap(), { $ });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_dollar" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_dollar" class="fn">peek_tt_dollar</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>$</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>($ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_dollar().unwrap(), { $ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_dollar" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_dollar" class="fn">peek_n_tt_dollar</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>$</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b $ <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_dollar(<span class="number">1</span>).unwrap(), { $ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_question" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_question" class="fn">next_tt_question</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>?</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="question-mark">? </span><span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_question().unwrap(), { <span class="question-mark">? </span>});
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_question" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_question" class="fn">peek_tt_question</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>?</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(<span class="question-mark">? </span><span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_question().unwrap(), { <span class="question-mark">? </span>});</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_question" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_question" class="fn">peek_n_tt_question</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>?</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b <span class="question-mark">? </span><span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_question(<span class="number">1</span>).unwrap(), { <span class="question-mark">? </span>});</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt_tilde" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt_tilde" class="fn">next_tt_tilde</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>~</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(~ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_tt_tilde().unwrap(), { ~ });
<span class="macro">assert_tokens!</span>(parser, { <span class="number">1 </span>b });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt_tilde" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt_tilde" class="fn">peek_tt_tilde</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>~</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(~ <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.peek_tt_tilde().unwrap(), { ~ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt_tilde" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt_tilde" class="fn">peek_n_tt_tilde</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the <code>n</code>th token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> <code>~</code> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s tt</a> without advancing the parser</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(b ~ <span class="number">1</span>));
<span class="macro">assert_tokens!</span>(parser.peek_n_tt_tilde(<span class="number">1</span>).unwrap(), { ~ });</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_tt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.next_tt" class="fn">next_tt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token tree as interpreted by the <code>tt</code> type in <code>macro_rules</code>, i.e., any literal, group,
or <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">composed punctuation</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_tt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_tt" class="fn">peek_tt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Peeks the next token tree as interpreted by the <code>tt</code> type in <code>macro_rules</code>, i.e., any literal, group,
or <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">composed punctuation</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_n_tt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1004-1050">source</a><h4 class="code-header">pub fn <a href="#method.peek_n_tt" class="fn">peek_n_tt</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Peeks the next token tree from the <code>n</code>th token as interpreted by the <code>tt</code> type in <code>macro_rules</code>, i.e., any literal, group,
or <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">composed punctuation</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_macro_rules_tt" class="method"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#1064-1100">source</a><h4 class="code-header">pub fn <a href="#method.next_macro_rules_tt" class="fn">next_macro_rules_tt</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next token if it is a <a href="https://doc.rust-lang.org/reference/tokens.html#punctuation">punctuation token tree</a> following the same rules as <a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">macro_rule’s <code>tt</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro_utils::{assert_tokens, TokenParser};
<span class="kw">use </span>quote::quote;
<span class="kw">let </span><span class="kw-2">mut </span>parser = TokenParser::new(<span class="macro">quote!</span>(.. =. <span class="number">1 </span>b));
<span class="macro">assert_tokens!</span>(parser.next_macro_rules_tt().unwrap(), { .. });
<span class="macro">assert_tokens!</span>(parser.next_macro_rules_tt().unwrap(), { = });
<span class="macro">assert_tokens!</span>(parser, { . <span class="number">1 </span>b });</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#107">source</a><a href="#impl-Clone-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#107">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt; <a href="#" class="tooltip" data-notable-ty="TokenParser&lt;I, PEEKER_LEN&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/clone.rs.html#174">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#146-154">source</a><a href="#impl-From%3CT%3E-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>, IntoIter = I&gt;,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#151-153">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(value: T) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTokenParser%3CI,+PEEKER_LEN%3E%3E-for-TokenStream" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#156-164">source</a><a href="#impl-From%3CTokenParser%3CI,+PEEKER_LEN%3E%3E-for-TokenStream" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;&gt; for <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#161-163">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(value: <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-TokenParser" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#182-188">source</a><a href="#impl-FromStr-for-TokenParser" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#183">source</a><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = &lt;<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#185-187">source</a><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="https://doc.rust-lang.org/1.83.0/core/str/traits/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Iterator-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#166-180">source</a><a href="#impl-Iterator-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#170">source</a><a href="#associatedtype.Item" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle method-toggle" open><summary><section id="method.next" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#173-179">source</a><a href="#method.next" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#tymethod.next" class="fn">next</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</h4></section></summary><div class='docblock'>Advances the iterator and returns the next value. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#tymethod.next">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_chunk" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#110-114">source</a><a href="#method.next_chunk" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.next_chunk" class="fn">next_chunk</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;[Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.array.html">N</a>], <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/array/iter/struct.IntoIter.html" title="struct core::array::iter::IntoIter">IntoIter</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, N&gt;&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_next_chunk</code>)</span></div></span><div class='docblock'>Advances the iterator and returns an array containing the next <code>N</code> values. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.next_chunk">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.size_hint" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#188">source</a></span><a href="#method.size_hint" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.size_hint" class="fn">size_hint</a>(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>, <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;)</h4></section></summary><div class='docblock'>Returns the bounds on the remaining length of the iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.size_hint">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.count" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#224-226">source</a></span><a href="#method.count" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.count" class="fn">count</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Consumes the iterator, counting the number of iterations and returning it. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.count">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.last" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#253-255">source</a></span><a href="#method.last" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.last" class="fn">last</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Consumes the iterator, returning the last element. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.last">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.advance_by" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#301">source</a><a href="#method.advance_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.advance_by" class="fn">advance_by</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/num/nonzero/struct.NonZero.html" title="struct core::num::nonzero::NonZero">NonZero</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;&gt;</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_advance_by</code>)</span></div></span><div class='docblock'>Advances the iterator by <code>n</code> elements. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.advance_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.nth" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#353">source</a></span><a href="#method.nth" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.nth" class="fn">nth</a>(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;</h4></section></summary><div class='docblock'>Returns the <code>n</code>th element of the iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.nth">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.step_by" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#404-406">source</a></span><a href="#method.step_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.step_by" class="fn">step_by</a>(self, step: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/step_by/struct.StepBy.html" title="struct core::iter::adapters::step_by::StepBy">StepBy</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator starting at the same point, but stepping by
the given amount at each iteration. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.step_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#476-479">source</a></span><a href="#method.chain" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.chain" class="fn">chain</a>&lt;U&gt;(self, other: U) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/chain/struct.Chain.html" title="struct core::iter::adapters::chain::Chain">Chain</a>&lt;Self, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</div></h4></section></summary><div class='docblock'>Takes two iterators and creates a new iterator over both in sequence. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.chain">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.zip" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#595-598">source</a></span><a href="#method.zip" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.zip" class="fn">zip</a>&lt;U&gt;(self, other: U) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/zip/struct.Zip.html" title="struct core::iter::adapters::zip::Zip">Zip</a>&lt;Self, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,</div></h4></section></summary><div class='docblock'>‘Zips up’ two iterators into a single iterator of pairs. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.zip">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.intersperse_with" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#697-700">source</a><a href="#method.intersperse_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.intersperse_with" class="fn">intersperse_with</a>&lt;G&gt;(self, separator: G) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/intersperse/struct.IntersperseWith.html" title="struct core::iter::adapters::intersperse::IntersperseWith">IntersperseWith</a>&lt;Self, G&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    G: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_intersperse</code>)</span></div></span><div class='docblock'>Creates a new iterator which places an item generated by <code>separator</code>
between adjacent items of the original iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.intersperse_with">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.map" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#757-760">source</a></span><a href="#method.map" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map" class="fn">map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/map/struct.Map.html" title="struct core::iter::adapters::map::Map">Map</a>&lt;Self, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; B,</div></h4></section></summary><div class='docblock'>Takes a closure and creates an iterator which calls that closure on each
element. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.for_each" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#803-806">source</a></span><a href="#method.for_each" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.for_each" class="fn">for_each</a>&lt;F&gt;(self, f: F)<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>),</div></h4></section></summary><div class='docblock'>Calls a closure on each element of an iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.for_each">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.filter" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#880-883">source</a></span><a href="#method.filter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.filter" class="fn">filter</a>&lt;P&gt;(self, predicate: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/filter/struct.Filter.html" title="struct core::iter::adapters::filter::Filter">Filter</a>&lt;Self, P&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator which uses a closure to determine if an element
should be yielded. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.filter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.filter_map" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#926-929">source</a></span><a href="#method.filter_map" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.filter_map" class="fn">filter_map</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/filter_map/struct.FilterMap.html" title="struct core::iter::adapters::filter_map::FilterMap">FilterMap</a>&lt;Self, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator that both filters and maps. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.filter_map">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.enumerate" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#974-976">source</a></span><a href="#method.enumerate" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.enumerate" class="fn">enumerate</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/enumerate/struct.Enumerate.html" title="struct core::iter::adapters::enumerate::Enumerate">Enumerate</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator which gives the current iteration count as well as
the next value. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.enumerate">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.peekable" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1046-1048">source</a></span><a href="#method.peekable" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.peekable" class="fn">peekable</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/peekable/struct.Peekable.html" title="struct core::iter::adapters::peekable::Peekable">Peekable</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator which can use the <a href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/peekable/struct.Peekable.html#method.peek" title="method core::iter::adapters::peekable::Peekable::peek"><code>peek</code></a> and <a href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/peekable/struct.Peekable.html#method.peek_mut" title="method core::iter::adapters::peekable::Peekable::peek_mut"><code>peek_mut</code></a> methods
to look at the next element of the iterator without consuming it. See
their documentation for more information. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.peekable">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.skip_while" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1112-1115">source</a></span><a href="#method.skip_while" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.skip_while" class="fn">skip_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/skip_while/struct.SkipWhile.html" title="struct core::iter::adapters::skip_while::SkipWhile">SkipWhile</a>&lt;Self, P&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator that <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.skip" title="method core::iter::traits::iterator::Iterator::skip"><code>skip</code></a>s elements based on a predicate. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.skip_while">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.take_while" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1194-1197">source</a></span><a href="#method.take_while" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.take_while" class="fn">take_while</a>&lt;P&gt;(self, predicate: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/take_while/struct.TakeWhile.html" title="struct core::iter::adapters::take_while::TakeWhile">TakeWhile</a>&lt;Self, P&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator that yields elements based on a predicate. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.take_while">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.map_while" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.57.0">1.57.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1283-1286">source</a></span><a href="#method.map_while" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map_while" class="fn">map_while</a>&lt;B, P&gt;(self, predicate: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/map_while/struct.MapWhile.html" title="struct core::iter::adapters::map_while::MapWhile">MapWhile</a>&lt;Self, P&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator that both yields elements based on a predicate and maps. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map_while">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.skip" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1313-1315">source</a></span><a href="#method.skip" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.skip" class="fn">skip</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/skip/struct.Skip.html" title="struct core::iter::adapters::skip::Skip">Skip</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator that skips the first <code>n</code> elements. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.skip">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.take" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1367-1369">source</a></span><a href="#method.take" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.take" class="fn">take</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/take/struct.Take.html" title="struct core::iter::adapters::take::Take">Take</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator that yields the first <code>n</code> elements, or fewer
if the underlying iterator ends sooner. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.take">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.scan" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1415-1418">source</a></span><a href="#method.scan" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.scan" class="fn">scan</a>&lt;St, B, F&gt;(self, initial_state: St, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/scan/struct.Scan.html" title="struct core::iter::adapters::scan::Scan">Scan</a>&lt;Self, St, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut St</a>, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;B&gt;,</div></h4></section></summary><div class='docblock'>An iterator adapter which, like <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fold" title="method core::iter::traits::iterator::Iterator::fold"><code>fold</code></a>, holds internal state, but
unlike <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fold" title="method core::iter::traits::iterator::Iterator::fold"><code>fold</code></a>, produces a new iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.scan">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.flat_map" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1454-1458">source</a></span><a href="#method.flat_map" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.flat_map" class="fn">flat_map</a>&lt;U, F&gt;(self, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/flatten/struct.FlatMap.html" title="struct core::iter::adapters::flatten::FlatMap">FlatMap</a>&lt;Self, U, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; U,</div></h4></section></summary><div class='docblock'>Creates an iterator that works like map, but flattens nested structure. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.flat_map">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.map_windows" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1696-1699">source</a><a href="#method.map_windows" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map_windows" class="fn">map_windows</a>&lt;F, R, const N: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;(self, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/map_windows/struct.MapWindows.html" title="struct core::iter::adapters::map_windows::MapWindows">MapWindows</a>&lt;Self, F, N&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;[Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.array.html">N</a>]) -&gt; R,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_map_windows</code>)</span></div></span><div class='docblock'>Calls the given function <code>f</code> for each contiguous window of size <code>N</code> over
<code>self</code> and returns an iterator over the outputs of <code>f</code>. Like <a href="https://doc.rust-lang.org/1.83.0/std/primitive.slice.html#method.windows" title="method slice::windows"><code>slice::windows()</code></a>,
the windows during mapping overlap as well. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.map_windows">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.fuse" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1763-1765">source</a></span><a href="#method.fuse" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fuse" class="fn">fuse</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/fuse/struct.Fuse.html" title="struct core::iter::adapters::fuse::Fuse">Fuse</a>&lt;Self&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Creates an iterator which ends after the first <a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fuse">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.inspect" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1848-1851">source</a></span><a href="#method.inspect" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.inspect" class="fn">inspect</a>&lt;F&gt;(self, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/inspect/struct.Inspect.html" title="struct core::iter::adapters::inspect::Inspect">Inspect</a>&lt;Self, F&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>),</div></h4></section></summary><div class='docblock'>Does something with each element of an iterator, passing the value on. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.inspect">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.by_ref" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1877-1879">source</a></span><a href="#method.by_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.by_ref" class="fn">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Borrows an iterator, rather than consuming it. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.by_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.collect" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#1997-1999">source</a></span><a href="#method.collect" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.collect" class="fn">collect</a>&lt;B&gt;(self) -&gt; B<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Transforms an iterator into a collection. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.collect">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.collect_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2149-2151">source</a><a href="#method.collect_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.collect_into" class="fn">collect_into</a>&lt;E&gt;(self, collection: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut E</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut E</a><div class="where">where
    E: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_collect_into</code>)</span></div></span><div class='docblock'>Collects all the items from an iterator into a collection. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.collect_into">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.partition" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2182-2186">source</a></span><a href="#method.partition" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partition" class="fn">partition</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.tuple.html">(B, B)</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Consumes an iterator, creating two collections from it. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partition">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_partitioned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2303-2306">source</a><a href="#method.is_partitioned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_partitioned" class="fn">is_partitioned</a>&lt;P&gt;(self, predicate: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_is_partitioned</code>)</span></div></span><div class='docblock'>Checks if the elements of this iterator are partitioned according to the given predicate,
such that all those that return <code>true</code> precede all those that return <code>false</code>. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_partitioned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_fold" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2398-2402">source</a></span><a href="#method.try_fold" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_fold" class="fn">try_fold</a>&lt;B, F, R&gt;(&amp;mut self, init: B, f: F) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(B, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; R,
    R: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&lt;Output = B&gt;,</div></h4></section></summary><div class='docblock'>An iterator method that applies a function as long as it returns
successfully, producing a single, final value. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_fold">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_for_each" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2457-2461">source</a></span><a href="#method.try_for_each" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_for_each" class="fn">try_for_each</a>&lt;F, R&gt;(&amp;mut self, f: F) -&gt; R<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; R,
    R: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>&gt;,</div></h4></section></summary><div class='docblock'>An iterator method that applies a fallible function to each item in the
iterator, stopping at the first error and returning that error. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_for_each">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.fold" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2577-2580">source</a></span><a href="#method.fold" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fold" class="fn">fold</a>&lt;B, F&gt;(self, init: B, f: F) -&gt; B<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(B, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; B,</div></h4></section></summary><div class='docblock'>Folds every element into an accumulator by applying an operation,
returning the final result. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.fold">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.reduce" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2615-2618">source</a></span><a href="#method.reduce" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.reduce" class="fn">reduce</a>&lt;F&gt;(self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>,</div></h4></section></summary><div class='docblock'>Reduces the elements to a single one, by repeatedly applying a reducing
operation. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.reduce">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_reduce" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2687-2693">source</a><a href="#method.try_reduce" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_reduce" class="fn">try_reduce</a>&lt;R&gt;(
    &amp;mut self,
    f: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; R,
) -&gt; &lt;&lt;R as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html#associatedtype.Residual" title="type core::ops::try_trait::Try::Residual">Residual</a> as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html" title="trait core::ops::try_trait::Residual">Residual</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&lt;R as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html#associatedtype.Output" title="type core::ops::try_trait::Try::Output">Output</a>&gt;&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html#associatedtype.TryType" title="type core::ops::try_trait::Residual::TryType">TryType</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&lt;Output = Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,
    &lt;R as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html#associatedtype.Residual" title="type core::ops::try_trait::Try::Residual">Residual</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html" title="trait core::ops::try_trait::Residual">Residual</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;&gt;,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iterator_try_reduce</code>)</span></div></span><div class='docblock'>Reduces the elements to a single one by repeatedly applying a reducing operation. If the
closure returns a failure, the failure is propagated back to the caller immediately. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_reduce">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.all" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2746-2749">source</a></span><a href="#method.all" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.all" class="fn">all</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Tests if every element of the iterator matches a predicate. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.all">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.any" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2800-2803">source</a></span><a href="#method.any" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.any" class="fn">any</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Tests if any element of the iterator matches a predicate. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.any">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2864-2867">source</a></span><a href="#method.find" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.find" class="fn">find</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Searches for an element of an iterator that satisfies a predicate. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.find">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.find_map" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2896-2899">source</a></span><a href="#method.find_map" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.find_map" class="fn">find_map</a>&lt;B, F&gt;(&amp;mut self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;B&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;B&gt;,</div></h4></section></summary><div class='docblock'>Applies function to the elements of iterator and returns
the first non-none result. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.find_map">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_find" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#2955-2961">source</a><a href="#method.try_find" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_find" class="fn">try_find</a>&lt;R&gt;(
    &amp;mut self,
    f: impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; R,
) -&gt; &lt;&lt;R as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html#associatedtype.Residual" title="type core::ops::try_trait::Try::Residual">Residual</a> as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html" title="trait core::ops::try_trait::Residual">Residual</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html#associatedtype.TryType" title="type core::ops::try_trait::Residual::TryType">TryType</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>&gt;,
    &lt;R as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html" title="trait core::ops::try_trait::Try">Try</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Try.html#associatedtype.Residual" title="type core::ops::try_trait::Try::Residual">Residual</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/try_trait/trait.Residual.html" title="trait core::ops::try_trait::Residual">Residual</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;&gt;,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>try_find</code>)</span></div></span><div class='docblock'>Applies function to the elements of iterator and returns
the first true result or the first error. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.try_find">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.position" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3039-3042">source</a></span><a href="#method.position" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.position" class="fn">position</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Searches for an element in an iterator, returning its index. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.position">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max_by_key" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3214-3217">source</a></span><a href="#method.max_by_key" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.max_by_key" class="fn">max_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; B,</div></h4></section></summary><div class='docblock'>Returns the element that gives the maximum value from the
specified function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.max_by_key">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max_by" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3248-3251">source</a></span><a href="#method.max_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.max_by" class="fn">max_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,</div></h4></section></summary><div class='docblock'>Returns the element that gives the maximum value with respect to the
specified comparison function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.max_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min_by_key" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3276-3279">source</a></span><a href="#method.min_by_key" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.min_by_key" class="fn">min_by_key</a>&lt;B, F&gt;(self, f: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    B: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; B,</div></h4></section></summary><div class='docblock'>Returns the element that gives the minimum value from the
specified function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.min_by_key">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min_by" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.15.0">1.15.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3310-3313">source</a></span><a href="#method.min_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.min_by" class="fn">min_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,</div></h4></section></summary><div class='docblock'>Returns the element that gives the minimum value with respect to the
specified comparison function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.min_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.unzip" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3385-3389">source</a></span><a href="#method.unzip" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.unzip" class="fn">unzip</a>&lt;A, B, FromA, FromB&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.tuple.html">(FromA, FromB)</a><div class="where">where
    FromA: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;A&gt;,
    FromB: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;B&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.tuple.html">(A, B)</a>&gt;,</div></h4></section></summary><div class='docblock'>Converts an iterator of pairs into a pair of containers. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.unzip">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.copied" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3417-3420">source</a></span><a href="#method.copied" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.copied" class="fn">copied</a>&lt;'a, T&gt;(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/copied/struct.Copied.html" title="struct core::iter::adapters::copied::Copied">Copied</a>&lt;Self&gt;<div class="where">where
    T: 'a + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;'a T</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator which copies all of its elements. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.copied">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.cloned" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3466-3469">source</a></span><a href="#method.cloned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.cloned" class="fn">cloned</a>&lt;'a, T&gt;(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/cloned/struct.Cloned.html" title="struct core::iter::adapters::cloned::Cloned">Cloned</a>&lt;Self&gt;<div class="where">where
    T: 'a + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;'a T</a>&gt;,</div></h4></section></summary><div class='docblock'>Creates an iterator which <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html#tymethod.clone" title="method core::clone::Clone::clone"><code>clone</code></a>s all of its elements. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.cloned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.array_chunks" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3543-3545">source</a><a href="#method.array_chunks" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.array_chunks" class="fn">array_chunks</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt;(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/iter/adapters/array_chunks/struct.ArrayChunks.html" title="struct core::iter::adapters::array_chunks::ArrayChunks">ArrayChunks</a>&lt;Self, N&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_array_chunks</code>)</span></div></span><div class='docblock'>Returns an iterator over <code>N</code> elements of the iterator at a time. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.array_chunks">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sum" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3575-3578">source</a></span><a href="#method.sum" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.sum" class="fn">sum</a>&lt;S&gt;(self) -&gt; S<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    S: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/accum/trait.Sum.html" title="trait core::iter::traits::accum::Sum">Sum</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</div></h4></section></summary><div class='docblock'>Sums the elements of an iterator. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.sum">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.product" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3608-3611">source</a></span><a href="#method.product" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.product" class="fn">product</a>&lt;P&gt;(self) -&gt; P<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    P: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/accum/trait.Product.html" title="trait core::iter::traits::accum::Product">Product</a>&lt;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>&gt;,</div></h4></section></summary><div class='docblock'>Iterates over the entire iterator, multiplying all the elements <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.product">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.cmp_by" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3658-3662">source</a><a href="#method.cmp_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.cmp_by" class="fn">cmp_by</a>&lt;I, F&gt;(self, other: I, cmp: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'><a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">Lexicographically</a> compares the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> with those
of another with respect to the specified comparison function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.cmp_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3715-3719">source</a></span><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partial_cmp" class="fn">partial_cmp</a>&lt;I&gt;(self, other: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'><a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">Lexicographically</a> compares the <a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd"><code>PartialOrd</code></a> elements of
this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> with those of another. The comparison works like short-circuit
evaluation, returning a result without comparing the remaining elements.
As soon as an order can be determined, the evaluation stops and a result is returned. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.partial_cmp_by" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3752-3756">source</a><a href="#method.partial_cmp_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partial_cmp_by" class="fn">partial_cmp_by</a>&lt;I, F&gt;(self, other: I, partial_cmp: F) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'><a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">Lexicographically</a> compares the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> with those
of another with respect to the specified comparison function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.partial_cmp_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3786-3790">source</a></span><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.eq" class="fn">eq</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are equal to those of
another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.eq">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.eq_by" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3810-3814">source</a><a href="#method.eq_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.eq_by" class="fn">eq_by</a>&lt;I, F&gt;(self, other: I, eq: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>iter_order_by</code>)</span></div></span><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are equal to those of
another with respect to the specified equality function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.eq_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3843-3847">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.ne" class="fn">ne</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are not equal to those of
another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.ne">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3865-3869">source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.lt" class="fn">lt</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are <a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a>
less than those of another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3887-3891">source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.le" class="fn">le</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are <a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a>
less or equal to those of another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3909-3913">source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.gt" class="fn">gt</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are <a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a>
greater than those of another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3931-3935">source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.ge" class="fn">ge</a>&lt;I&gt;(self, other: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,
    Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Determines if the elements of this <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator"><code>Iterator</code></a> are <a href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.Ord.html#lexicographical-comparison" title="trait core::cmp::Ord">lexicographically</a>
greater than or equal to those of another. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.ge">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_sorted_by" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#3988-3991">source</a></span><a href="#method.is_sorted_by" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_sorted_by" class="fn">is_sorted_by</a>&lt;F&gt;(self, compare: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>, &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Checks if the elements of this iterator are sorted using the given comparator function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_sorted_by">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_sorted_by_key" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span> · <a class="src" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/iterator.rs.html#4033-4037">source</a></span><a href="#method.is_sorted_by_key" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_sorted_by_key" class="fn">is_sorted_by_key</a>&lt;F, K&gt;(self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>) -&gt; K,
    K: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>,</div></h4></section></summary><div class='docblock'>Checks if the elements of this iterator are sorted using the given key extraction
function. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#method.is_sorted_by_key">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ToTokens-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#191-211">source</a><a href="#impl-ToTokens-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="../proc_macro2/enum.TokenTree.html" title="enum proc_macro2::TokenTree">TokenTree</a>&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_tokens" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#195-197">source</a><a href="#method.to_tokens" class="anchor">§</a><h4 class="code-header">fn <a href="../quote/to_tokens/trait.ToTokens.html#tymethod.to_tokens" class="fn">to_tokens</a>(&amp;self, tokens: &amp;mut <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>)</h4></section></summary><div class='docblock'>Write <code>self</code> to the given <code>TokenStream</code>. <a href="../quote/to_tokens/trait.ToTokens.html#tymethod.to_tokens">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.to_token_stream" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#200-202">source</a><a href="#method.to_token_stream" class="anchor">§</a><h4 class="code-header">fn <a href="../quote/to_tokens/trait.ToTokens.html#method.to_token_stream" class="fn">to_token_stream</a>(&amp;self) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></h4></section></summary><div class='docblock'>Convert <code>self</code> directly into a <code>TokenStream</code> object. <a href="../quote/to_tokens/trait.ToTokens.html#method.to_token_stream">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_token_stream-1" class="method trait-impl"><a class="src rightside" href="../src/proc_macro_utils/parser.rs.html#205-210">source</a><a href="#method.into_token_stream-1" class="anchor">§</a><h4 class="code-header">fn <a href="../quote/to_tokens/trait.ToTokens.html#method.into_token_stream" class="fn">into_token_stream</a>(self) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a><div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Convert <code>self</code> directly into a <code>TokenStream</code> object. <a href="../quote/to_tokens/trait.ToTokens.html#method.into_token_stream">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-Freeze-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-RefUnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-Send-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I = <a class="struct" href="../proc_macro2/token_stream/struct.IntoIter.html" title="struct proc_macro2::token_stream::IntoIter">IntoIter</a>, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a> = 6&gt; !<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;</h3></section><section id="impl-Sync-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-Sync-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I = <a class="struct" href="../proc_macro2/token_stream/struct.IntoIter.html" title="struct proc_macro2::token_stream::IntoIter">IntoIter</a>, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a> = 6&gt; !<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;</h3></section><section id="impl-Unpin-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-Unpin-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" class="impl"><a href="#impl-UnwindSafe-for-TokenParser%3CI,+PEEKER_LEN%3E" class="anchor">§</a><h3 class="code-header">impl&lt;I, const PEEKER_LEN: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.TokenParser.html" title="struct proc_macro_utils::TokenParser">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/any.rs.html#138">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/any.rs.html#139">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#211">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/clone.rs.html#273">source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/clone.rs.html#275">source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut T</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/1.83.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#768">source</a><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoIterator-for-I" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/collect.rs.html#351">source</a><a href="#impl-IntoIterator-for-I" class="anchor">§</a><h3 class="code-header">impl&lt;I&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for I<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Item-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/collect.rs.html#352">source</a><a href="#associatedtype.Item-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></h4></section></summary><div class='docblock'>The type of the elements being iterated over.</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/collect.rs.html#353">source</a><a href="#associatedtype.IntoIter" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = I</h4></section></summary><div class='docblock'>Which kind of iterator are we turning this into?</div></details><details class="toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/iter/traits/collect.rs.html#356">source</a><a href="#method.into_iter" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; I</h4></section></summary><div class='docblock'>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.83.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/alloc/borrow.rs.html#82-84">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/alloc/borrow.rs.html#86">source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.83.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#809">source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#794">source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"TokenParser<I, 6>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TokenParser.html\" title=\"struct proc_macro_utils::TokenParser\">TokenParser</a>&lt;I, PEEKER_LEN&gt;</code></h3><pre><code><div class=\"where\">impl&lt;I, const PEEKER_LEN: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.83.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TokenParser.html\" title=\"struct proc_macro_utils::TokenParser\">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"enum\" href=\"../proc_macro2/enum.TokenTree.html\" title=\"enum proc_macro2::TokenTree\">TokenTree</a>&gt;,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../proc_macro2/enum.TokenTree.html\" title=\"enum proc_macro2::TokenTree\">TokenTree</a>;</div>","TokenParser<I, PEEKER_LEN>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TokenParser.html\" title=\"struct proc_macro_utils::TokenParser\">TokenParser</a>&lt;I, PEEKER_LEN&gt;</code></h3><pre><code><div class=\"where\">impl&lt;I, const PEEKER_LEN: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.83.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TokenParser.html\" title=\"struct proc_macro_utils::TokenParser\">TokenParser</a>&lt;I, PEEKER_LEN&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a>&lt;Item = <a class=\"enum\" href=\"../proc_macro2/enum.TokenTree.html\" title=\"enum proc_macro2::TokenTree\">TokenTree</a>&gt;,</div></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"../proc_macro2/enum.TokenTree.html\" title=\"enum proc_macro2::TokenTree\">TokenTree</a>;</div>"}</script></section></div></main></body></html>